@using System.Reflection
@using Humanizer
@model BoardDefinition
@{
    var boardName = Model.GetType().GetCustomAttribute<BoardAttribute>()!.Name;
    var driverDevices = new Dictionary<Guid, List<string>>();
    string DeviceTypeToString(DeviceNode deviceNode)
        => deviceNode switch
        {
            SimpleDeviceNode => "simple",
            SimpleBusNode => "bus",
            _ => "unknown"
        };
    string PropertyType(object prop)
        => prop switch
        {
            byte => "uint8_t",
            ushort => "uint16_t",
            uint => "uint32_t",
            ulong => "uint64_t",
            sbyte => "int8_t",
            short => "int16_t",
            int => "int32_t",
            long => "int64_t",
            string => "std::string_view",
            _ => "auto"
        };
    string PropertyValue(object prop)
        => prop switch
        {
            byte or ushort or uint or ulong or sbyte or short or int or long => prop.ToString()!,
            string => $"\"{prop}\"",
            _ => prop.ToString()!,
        };
    void RecordMatchDriver(DeviceNode device, string typePath)
    {
        DriverDefinition? driver = null;
        foreach (var compat in device.Compatibles)
        {
            driver = Model.Drivers.FirstOrDefault(x => x.Compatibles.Contains(compat));
            if (driver != null) break;
        }

        if (driver != null)
        {
            if (!driverDevices.TryGetValue(driver.Id, out var devices))
            {
                devices = new();
                driverDevices.Add(driver.Id, devices);
            }

            devices.Add(typePath);
        }
    }
}
﻿// This file is generated by Chino configuration generator.
#pragma once
#include <chino/os/hal/hal_meta.h>
#include <tuple>

namespace chino::os::hal::meta {
struct board_desc {
    static constexpr uuid id = @(Model.Id.ToString("X"));
    static constexpr std::string_view name = "@(Html.Raw(boardName))";

    struct chip {
        static constexpr uuid id = @(Model.Chip.Id.ToString("X"));
        static constexpr std::string_view name = "@(Html.Raw(Model.Chip.Name))";
        static constexpr std::string_view vendor = "@(Html.Raw(Model.Chip.Vendor))";

        struct machine {
            static constexpr std::string_view name = "@(Html.Raw(Model.Chip.Machine.Name))";

            struct devices {
                @foreach (var device in Model.Chip.Machine.Devices)
                {
                    RecordMatchDriver(device, $"board_desc::chip::machine::devices::{device.Name}");
@:                struct @device.Name {
@:                    static constexpr device_meta_kind kind = device_meta_kind::@(DeviceTypeToString(device));
@:                    static constexpr std::array<uuid, @device.Compatibles.Count> compatibles = {@string.Join(", ", device.Compatibles.Select(x => $"uuid{x:X}"))};
@:
@:                    struct properties {
                    @foreach (var prop in device.Properties)
                    {
@:                        static constexpr @Html.Raw(PropertyType(prop.Value)) @prop.Key.Camelize() = @Html.Raw(PropertyValue(prop.Value));
                    }
@:
@:                        static constexpr size_t size() noexcept { return @device.Properties.Count; }
@:                    };
@:                };
@:
                }
                static constexpr size_t size() noexcept { return @Model.Chip.Machine.Devices.Count; }
            };
        };
    };

    struct drivers {
        @foreach (var driver in Model.Drivers)
        {
            List<string>? devices;
            driverDevices.TryGetValue(driver.Id, out devices);
@:        struct @driver.Name {
@:            static constexpr uuid id = @(driver.Id.ToString("X"));
@:            static constexpr std::array<uuid, @driver.Compatibles.Count> compatibles = {@string.Join(", ", driver.Compatibles.Select(x => $"uuid{x:X}"))};
@:            static constexpr std::tuple<@(devices != null ? string.Join(", ", devices.Select(x => $"{x}")) : string.Empty)> attached_devices = {};
@:        };
@:
        }
    };
};

template<class TDevice>
constexpr auto find_driver() noexcept {
    @foreach (var driver in driverDevices)
    {
@:    if constexpr (@Html.Raw(string.Join(" || ", driver.Value.Select(x => $"std::is_same_v<TDevice, {x}>"))))
@:        return board_desc::drivers::@Model.Drivers.First(x => x.Id == driver.Key).Name{};
    }
}
} // namespace chino::os::hal::meta
